import { GQtyError } from '../Error/index.mjs';
import { parseSchemaType } from '../Schema/types.mjs';
import { isInteger } from '../Utils/index.mjs';
import { SelectionType } from './selection.mjs';

function createSelectionBuilder(innerState) {
  const {
    selectionManager,
    schema,
    scalarsEnumsHash,
    schemaUnions: { unions: schemaUnions }
  } = innerState;
  return function buildSelection(...[typeInput, ...input]) {
    var _a, _b, _c;
    let type;
    switch (typeInput) {
      case "subscription": {
        type = SelectionType.Subscription;
        break;
      }
      case "mutation": {
        type = SelectionType.Mutation;
        break;
      }
      case "query": {
        type = SelectionType.Query;
        break;
      }
      default:
        throw new GQtyError('Invalid initial selection build argument, specify "query", "mutation" or "subscription"', {
          caller: buildSelection
        });
    }
    let prevSelection = selectionManager.getSelection({
      key: typeInput,
      type
    });
    let isArraySelection = false;
    let schemaType = schema[typeInput];
    let unionType;
    for (const [index, inputValue] of input.entries()) {
      let key;
      let args;
      let unions;
      if (typeof inputValue !== "object") {
        key = inputValue;
      } else {
        key = inputValue[0];
        args = (_a = inputValue[1]) == null ? void 0 : _a.args;
        unions = unionType ? (_b = inputValue[1]) == null ? void 0 : _b.unions : void 0;
      }
      unions || (unions = (_c = unionType == null ? void 0 : unionType.fieldsMap[key]) == null ? void 0 : _c.typesNames);
      if (isArraySelection) {
        let arrayIndex;
        try {
          arrayIndex = parseInt(key);
        } catch (err) {
        }
        if (isInteger(arrayIndex)) {
          prevSelection = selectionManager.getSelection({
            key,
            prevSelection
          });
          isArraySelection = false;
          continue;
        } else {
          prevSelection = selectionManager.getSelection({
            key: 0,
            prevSelection
          });
        }
      }
      const schemaTypeValue = schemaType[key];
      if (!schemaTypeValue)
        throw new GQtyError(`Invalid selection argument at index ${index}: ${JSON.stringify(key)}, possible valid keys: '${Object.keys(schemaType).map((v) => `"${v}"`).join(" | ")}'`, {
          caller: buildSelection
        });
      const { __type, __args: argTypes } = schemaTypeValue;
      const { pureType, isArray } = parseSchemaType(__type);
      isArraySelection = isArray;
      prevSelection = selectionManager.getSelection({
        key,
        prevSelection,
        args: argTypes ? args || {} : args,
        argTypes,
        unions
      });
      if (scalarsEnumsHash[pureType]) {
        schemaType = {};
        continue;
      }
      let typeValue;
      if (unionType = schemaUnions[pureType]) {
        typeValue = unionType.combinedTypes;
      } else {
        typeValue = schema[pureType];
      }
      if (!typeValue)
        throw new GQtyError("Invalid schema type", {
          caller: buildSelection
        });
      schemaType = typeValue;
    }
    return prevSelection;
  };
}

export { createSelectionBuilder };
