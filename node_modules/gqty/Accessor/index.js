'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('../Error/index.js');
const types = require('../Schema/types.js');
const selection = require('../Selection/selection.js');
const index$1 = require('../Utils/index.js');
const cycle = require('../Utils/cycle.js');
const object = require('../Utils/object.js');

const ProxySymbol = Symbol("gqty-proxy");
class SchemaUnion {
}
function createSchemaUnions(schema) {
  const unionObjectTypesForSelections = {};
  const unions = Object.entries(schema[types.SchemaUnionsKey] || {}).reduce((acum, [name, unionTypes]) => {
    const fieldsSet = new Set();
    const fieldsMap = {};
    const combinedTypes = {};
    const types = unionTypes.reduce((typeAcum, objectTypeName) => {
      unionObjectTypesForSelections[objectTypeName] || (unionObjectTypesForSelections[objectTypeName] = [objectTypeName]);
      const objectType = schema[objectTypeName];
      if (objectType) {
        for (const objectTypeFieldName of Object.keys(objectType)) {
          fieldsMap[objectTypeFieldName] || (fieldsMap[objectTypeFieldName] = {
            list: [],
            typesNames: [],
            combinedTypes: {}
          });
          fieldsMap[objectTypeFieldName].list.push({
            type: objectType,
            objectTypeName
          });
          Object.assign(fieldsMap[objectTypeFieldName].combinedTypes, objectType);
          Object.assign(combinedTypes, objectType);
          fieldsSet.add(objectTypeFieldName);
        }
        typeAcum[objectTypeName] = objectType;
      }
      return typeAcum;
    }, {});
    for (const fieldMapValue of Object.values(fieldsMap)) {
      fieldMapValue.typesNames = fieldMapValue.list.map((v) => v.objectTypeName);
    }
    acum[name] = Object.assign(new SchemaUnion(), {
      name,
      types,
      fieldsProxy: Array.from(fieldsSet).reduce((fieldsAcum, fieldName) => {
        fieldsAcum[fieldName] = ProxySymbol;
        return fieldsAcum;
      }, {}),
      fieldsMap,
      combinedTypes
    });
    return acum;
  }, {});
  return {
    unions,
    unionObjectTypesForSelections
  };
}
function createAccessorCreators(innerState) {
  const {
    accessorCache,
    selectionManager,
    interceptorManager,
    scalarsEnumsHash,
    schema,
    eventHandler,
    schemaUnions: { unions: schemaUnions, unionObjectTypesForSelections },
    clientCache: schedulerClientCache,
    scheduler: {
      errors: { map: schedulerErrorsMap }
    },
    normalizationHandler
  } = innerState;
  const ResolveInfoSymbol = Symbol();
  const proxySymbolArray = [ProxySymbol];
  function extractDataFromProxy(value) {
    if (accessorCache.isProxy(value)) {
      const accessorSelection = accessorCache.getProxySelection(value);
      if (!accessorSelection)
        return;
      const selectionCache = innerState.clientCache.getCacheFromSelection(accessorSelection);
      if (selectionCache === void 0)
        return;
      return selectionCache;
    } else if (object.isObject(value)) {
      return cycle.retrocycle(JSON.parse(JSON.stringify(value)));
    }
    return value;
  }
  function setCache(accessorOrSelection, dataOrArgs, possibleData) {
    if (accessorOrSelection instanceof selection.Selection) {
      const data = extractDataFromProxy(dataOrArgs);
      innerState.clientCache.setCacheFromSelection(accessorOrSelection, data);
      eventHandler.sendCacheChange({
        data,
        selection: accessorOrSelection
      });
    } else if (typeof accessorOrSelection === "function") {
      if (dataOrArgs !== void 0 && typeof dataOrArgs !== "object") {
        throw new index.GQtyError("Invalid arguments of type: " + typeof dataOrArgs, {
          caller: setCache
        });
      }
      const resolveInfo = accessorOrSelection[ResolveInfoSymbol];
      if (!resolveInfo) {
        throw new index.GQtyError("Invalid gqty function", {
          caller: setCache
        });
      }
      const selection = innerState.selectionManager.getSelection({
        ...resolveInfo,
        args: dataOrArgs
      });
      const data = extractDataFromProxy(possibleData);
      innerState.clientCache.setCacheFromSelection(selection, data);
      eventHandler.sendCacheChange({
        data,
        selection
      });
    } else if (accessorCache.isProxy(accessorOrSelection)) {
      const selection = accessorCache.getProxySelection(accessorOrSelection);
      if (!selection) {
        throw new index.GQtyError("Invalid proxy selection", {
          caller: setCache
        });
      }
      const data = extractDataFromProxy(dataOrArgs);
      innerState.clientCache.setCacheFromSelection(selection, data);
      eventHandler.sendCacheChange({
        data,
        selection
      });
    } else {
      throw new index.GQtyError("Invalid gqty proxy", {
        caller: setCache
      });
    }
  }
  function createArrayAccessor(schemaValue, prevSelection, unions, parentTypename) {
    const arrayCacheValue = innerState.clientCache.getCacheFromSelection(prevSelection);
    if (innerState.allowCache && arrayCacheValue === null)
      return null;
    const proxyValue = arrayCacheValue === void 0 || !Array.isArray(arrayCacheValue) || !innerState.allowCache && Array.isArray(arrayCacheValue) && arrayCacheValue.length === 0 ? proxySymbolArray : arrayCacheValue;
    const accessor = accessorCache.getArrayAccessor(prevSelection, proxyValue, () => {
      return new Proxy(proxyValue, {
        set(_target, key, value) {
          let index;
          try {
            index = parseInt(key);
          } catch (err) {
          }
          if (index$1.isInteger(index)) {
            const selection = innerState.selectionManager.getSelection({
              key: index,
              prevSelection
            });
            const data = extractDataFromProxy(value);
            innerState.clientCache.setCacheFromSelection(selection, data);
            eventHandler.sendCacheChange({
              selection,
              data
            });
            return true;
          }
          if (key === "length") {
            if (!Array.isArray(arrayCacheValue)) {
              console.warn("Invalid array assignation to unresolved proxy array");
              return true;
            }
            Reflect.set(arrayCacheValue, key, value);
            eventHandler.sendCacheChange({
              selection: prevSelection,
              data: innerState.clientCache.getCacheFromSelection(prevSelection)
            });
            return true;
          }
          throw TypeError("Invalid array assignation: " + key);
        },
        get(target, key, receiver) {
          if (key === "length") {
            if (proxyValue === proxySymbolArray) {
              const lengthSelection = innerState.selectionManager.getSelection({
                key: 0,
                prevSelection
              });
              const childAccessor = createAccessor(schemaValue, lengthSelection, unions, parentTypename);
              accessorCache.addAccessorChild(accessor, childAccessor);
              if (childAccessor)
                Reflect.get(childAccessor, "__typename");
            }
            return target.length;
          } else if (key === "toJSON") {
            return () => cycle.decycle(innerState.clientCache.getCacheFromSelection(prevSelection, []));
          }
          let index;
          try {
            index = parseInt(key);
          } catch (err) {
          }
          if (index$1.isInteger(index)) {
            const selection = innerState.selectionManager.getSelection({
              key: index,
              prevSelection
            });
            interceptorManager.addSelectionCache(selection);
            if (innerState.allowCache && arrayCacheValue !== void 0 && (arrayCacheValue == null ? void 0 : arrayCacheValue[index]) == null) {
              return arrayCacheValue == null ? void 0 : arrayCacheValue[index];
            }
            const childAccessor = createAccessor(schemaValue, selection, unions, parentTypename);
            accessorCache.addAccessorChild(accessor, childAccessor);
            return childAccessor;
          }
          return Reflect.get(target, key, receiver);
        }
      });
    });
    return accessor;
  }
  const notFoundObjectKey = {};
  const nullObjectKey = {};
  const unionsCacheValueMap = new WeakMap();
  function getCacheValueReference(cacheValue, unions) {
    if (unions === void 0)
      return cacheValue;
    const mapKey = cacheValue == null ? nullObjectKey : typeof cacheValue === "object" ? cacheValue : notFoundObjectKey;
    let cacheValueMap = unionsCacheValueMap.get(unions);
    if (!cacheValueMap) {
      cacheValueMap = new WeakMap();
      cacheValueMap.set(unions, mapKey);
    }
    let cacheReference = cacheValueMap.get(mapKey);
    if (!cacheReference) {
      cacheReference = {};
      cacheValueMap.set(mapKey, cacheReference);
    }
    return cacheReference;
  }
  function getTypename(selection) {
    const cacheValue = innerState.clientCache.getCacheFromSelection(selection);
    if (object.isObjectWithType(cacheValue))
      return cacheValue.__typename;
    interceptorManager.addSelection(innerState.selectionManager.getSelection({
      key: "__typename",
      prevSelection: selection
    }));
  }
  const emptyScalarArray = Object.freeze([]);
  const querySelection = selectionManager.getSelection({
    key: "query",
    type: selection.SelectionType.Query
  });
  const mutationSelection = selectionManager.getSelection({
    key: "mutation",
    type: selection.SelectionType.Mutation
  });
  const subscriptionSelection = selectionManager.getSelection({
    key: "subscription",
    type: selection.SelectionType.Subscription
  });
  function createAccessor(schemaValue, prevSelection, unions, parentTypename) {
    let cacheValue = innerState.clientCache.getCacheFromSelection(prevSelection);
    if (innerState.allowCache && cacheValue === null)
      return null;
    const accessor = accessorCache.getAccessor(prevSelection, getCacheValueReference(cacheValue, unions), () => {
      const autoFetchKeys = normalizationHandler && (parentTypename || unions) ? () => {
        if (unions) {
          const schemaKeys = normalizationHandler.schemaKeys;
          for (const objectTypeName of unions) {
            const objectNormalizationKeys = schemaKeys[objectTypeName];
            if (objectNormalizationKeys) {
              for (const key of objectNormalizationKeys) {
                interceptorManager.addSelection(innerState.selectionManager.getSelection({
                  key,
                  prevSelection,
                  unions: unionObjectTypesForSelections[objectTypeName] || [objectTypeName]
                }));
              }
            }
          }
        } else if (parentTypename) {
          const normalizationKeys = normalizationHandler.schemaKeys[parentTypename];
          if (normalizationKeys) {
            for (const key of normalizationKeys) {
              interceptorManager.addSelection(innerState.selectionManager.getSelection({
                key,
                prevSelection
              }));
            }
          }
        }
      } : void 0;
      const proxyValue = schemaValue instanceof SchemaUnion ? schemaValue.fieldsProxy : Object.keys(schemaValue).reduce((acum, key) => {
        acum[key] = ProxySymbol;
        return acum;
      }, {});
      return new Proxy(proxyValue, {
        set(_target, key, value) {
          if (!proxyValue.hasOwnProperty(key))
            throw TypeError("Invalid proxy assignation");
          const targetSelection = innerState.selectionManager.getSelection({
            key,
            prevSelection,
            unions
          });
          const data = extractDataFromProxy(value);
          innerState.clientCache.setCacheFromSelection(targetSelection, data);
          eventHandler.sendCacheChange({
            data,
            selection: targetSelection
          });
          return true;
        },
        get(target, key, receiver) {
          if (key === "toJSON")
            return () => cycle.decycle(innerState.clientCache.getCacheFromSelection(prevSelection, {}));
          if (!proxyValue.hasOwnProperty(key))
            return Reflect.get(target, key, receiver);
          if (schemaValue instanceof SchemaUnion) {
            let unionTypeName = getTypename(prevSelection);
            let objectType;
            let selectionUnions;
            if (unionTypeName) {
              objectType = schemaValue.types[unionTypeName];
              selectionUnions = unionObjectTypesForSelections[unionTypeName] || [unionTypeName];
            } else {
              ({ combinedTypes: objectType, typesNames: selectionUnions } = schemaValue.fieldsMap[key]);
            }
            const proxy = createAccessor(objectType, prevSelection, selectionUnions, parentTypename);
            return proxy && Reflect.get(proxy, key);
          } else {
            const { __type, __args } = schemaValue[key];
            const { pureType, isArray } = types.parseSchemaType(__type);
            const resolve = (args) => {
              const selection = innerState.selectionManager.getSelection({
                key,
                prevSelection,
                args: args != null ? args.argValues : void 0,
                argTypes: args != null ? args.argTypes : void 0,
                unions
              });
              interceptorManager.addSelectionCache(selection);
              if (scalarsEnumsHash[pureType]) {
                const cacheValue2 = innerState.clientCache.getCacheFromSelection(selection);
                accessorCache.addSelectionToAccessorHistory(accessor, selection);
                if (cacheValue2 === void 0) {
                  innerState.foundValidCache = false;
                  if (selection.type === 2 || schedulerClientCache !== innerState.clientCache || !schedulerErrorsMap.has(selection)) {
                    autoFetchKeys == null ? void 0 : autoFetchKeys();
                    interceptorManager.addSelection(selection);
                  }
                  return isArray ? emptyScalarArray : void 0;
                } else if (!innerState.allowCache || selection.type === 2) {
                  autoFetchKeys == null ? void 0 : autoFetchKeys();
                  interceptorManager.addSelection(selection);
                } else {
                  interceptorManager.addSelectionCacheRefetch(selection);
                }
                return cacheValue2;
              }
              const typeValue = schema[pureType] || schemaUnions[pureType];
              if (typeValue) {
                const childAccessor = (isArray ? createArrayAccessor : createAccessor)(typeValue, selection, void 0, pureType);
                accessorCache.addAccessorChild(accessor, childAccessor);
                return childAccessor;
              }
              throw new index.GQtyError(`GraphQL Type not found: ${pureType}, available fields: "${Object.keys(schemaValue).join(" | ")}"`);
            };
            if (__args) {
              const resolveInfo = {
                key,
                prevSelection,
                argTypes: __args
              };
              return Object.assign(function ProxyFn(argValues = emptyVariablesObject) {
                return resolve({
                  argValues,
                  argTypes: __args
                });
              }, {
                [ResolveInfoSymbol]: resolveInfo
              });
            }
            return resolve();
          }
        }
      });
    });
    return accessor;
  }
  const query = createAccessor(schema.query, querySelection);
  const mutation = createAccessor(schema.mutation, mutationSelection);
  const subscription = createAccessor(schema.subscription, subscriptionSelection);
  function assignSelections(source, target) {
    if (source == null || target == null)
      return;
    let sourceSelection;
    let targetSelection;
    if (!accessorCache.isProxy(source) || !(sourceSelection = accessorCache.getProxySelection(source)))
      throw new index.GQtyError("Invalid source proxy", {
        caller: assignSelections
      });
    if (!accessorCache.isProxy(target) || !(targetSelection = accessorCache.getProxySelection(target)))
      throw new index.GQtyError("Invalid target proxy", {
        caller: assignSelections
      });
    const sourceSelections = accessorCache.getSelectionSetHistory(source);
    if (!sourceSelections) {
      if (process.env.NODE_ENV !== "production") {
        console.warn("Source proxy doesn't have any selections made");
      }
      return;
    }
    for (const selection of sourceSelections) {
      let mappedSelection = targetSelection;
      const filteredSelections = selection.selectionsList.filter((value) => !sourceSelection.selectionsList.includes(value));
      for (const { key, args, argTypes } of filteredSelections) {
        mappedSelection = innerState.selectionManager.getSelection({
          key,
          args,
          argTypes,
          prevSelection: mappedSelection
        });
      }
      accessorCache.addSelectionToAccessorHistory(target, mappedSelection);
      interceptorManager.addSelection(mappedSelection);
    }
  }
  return {
    createAccessor,
    createArrayAccessor,
    assignSelections,
    setCache,
    query,
    mutation,
    subscription
  };
}
const emptyVariablesObject = {};

exports.SchemaUnion = SchemaUnion;
exports.createAccessorCreators = createAccessorCreators;
exports.createSchemaUnions = createSchemaUnions;
