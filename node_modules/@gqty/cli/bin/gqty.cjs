#!/usr/bin/env node
'use strict';

const prettier = require('prettier');
const cosmiconfig = require('cosmiconfig');
const fs = require('fs');
const module$1 = require('module');
const path = require('path');
const gqty = require('gqty');
const graphql = require('graphql');
const core = require('@graphql-codegen/core');
const typescriptPlugin = require('@graphql-codegen/typescript');
const utils = require('@graphql-tools/utils');
const crossFetch = require('cross-fetch');
const wrap = require('@graphql-tools/wrap');
const mkdirp = require('mkdirp');
const commander = require('commander');
const url = require('url');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

const prettier__default = /*#__PURE__*/_interopDefaultLegacy(prettier);
const typescriptPlugin__namespace = /*#__PURE__*/_interopNamespace(typescriptPlugin);
const mkdirp__default = /*#__PURE__*/_interopDefaultLegacy(mkdirp);

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/innerState.ts
var __innerState;
var init_innerState = __esm({
  "src/innerState.ts"() {
    __innerState = {
      isCLI: false
    };
  }
});

// src/prettier.ts
var prettier_exports = {};
__export(prettier_exports, {
  formatPrettier: () => formatPrettier
});
function formatPrettier(defaultOptions) {
  const configPromise = commonConfig.then((config) => Object.assign({}, config, defaultOptions));
  return {
    async format(input) {
      return prettierFormat(input, await configPromise);
    }
  };
}
var prettierFormat, resolveConfig, commonConfig;
var init_prettier = __esm({
  "src/prettier.ts"() {
    ({ format: prettierFormat, resolveConfig } = prettier__default['default']);
    commonConfig = resolveConfig(process.cwd());
  }
});
function isPlainObject(v) {
  return v != null && typeof v === "object" && !Array.isArray(v);
}
function isStringRecord(v) {
  return isPlainObject(v) && Object.values(v).every((v2) => typeof v2 === "string");
}
function warnConfig(fieldName, invalidValue, expectedValue, defaultValue) {
  console.warn(`Warning, invalid config ${fieldName}, got: ${JSON.stringify(invalidValue)}, expected ${expectedValue}. ${JSON.stringify(defaultValue)} used instead.`);
}
function getValidConfig(v) {
  if (isPlainObject(v)) {
    const newConfig = {};
    if (typeof v.javascriptOutput === "boolean") {
      newConfig.javascriptOutput = v.javascriptOutput;
    }
    for (const [key, value] of Object.entries(v)) {
      if (value === void 0)
        continue;
      switch (key) {
        case "destination":
        case "preImport": {
          if (typeof value === "string") {
            newConfig[key] = value;
          } else {
            warnConfig(key, value, "string", defaultConfig[key]);
          }
          break;
        }
        case "javascriptOutput":
        case "react":
        case "subscriptions":
        case "enumsAsStrings": {
          if (typeof value === "boolean") {
            newConfig[key] = value;
          } else {
            warnConfig(key, value, "boolean", defaultConfig[key]);
          }
          break;
        }
        case "scalarTypes": {
          if (isStringRecord(value)) {
            newConfig[key] = value;
          } else {
            warnConfig(key, value, '"object of strings"', defaultConfig[key]);
          }
          break;
        }
        case "introspection": {
          if (isPlainObject(value)) {
            const introspectionOptions = {};
            for (const [introspectionKey, introspectionValue] of Object.entries(value)) {
              if (introspectionValue === void 0)
                continue;
              switch (introspectionKey) {
                case "endpoint": {
                  if (typeof introspectionValue === "string") {
                    introspectionOptions[introspectionKey] = introspectionValue;
                  } else {
                    warnConfig(`${key}.${introspectionKey}`, introspectionValue, "string", defaultConfig.introspection.endpoint);
                  }
                  break;
                }
                case "headers": {
                  if (isStringRecord(introspectionValue)) {
                    introspectionOptions[introspectionKey] = introspectionValue;
                  } else {
                    warnConfig(`${key}.${introspectionKey}`, introspectionValue, '"object of strings"', defaultConfig.introspection.headers);
                  }
                  break;
                }
                default: {
                  console.warn(`Warning, invalid and unused config property "${key}.${introspectionKey}": ${JSON.stringify(value)}`);
                }
              }
            }
            newConfig[key] = introspectionOptions;
          } else {
            warnConfig(key, value, "object", defaultConfig[key]);
          }
          break;
        }
        default:
          console.warn(`Warning, invalid and unused config property "${key}": ${JSON.stringify(value)}`);
      }
    }
    return newConfig;
  } else {
    console.warn("Invalid config, using instead: " + JSON.stringify(defaultConfig, null, 2));
    return defaultConfig;
  }
}
var DUMMY_ENDPOINT, defaultConfig, defaultFilePath, defaultGQtyConfig, gqtyConfigPromise;
var init_config = __esm({
  "src/config.ts"() {
    init_innerState();
    DUMMY_ENDPOINT = "SPECIFY_ENDPOINT_OR_SCHEMA_FILE_PATH_HERE";
    defaultConfig = {
      react: true,
      scalarTypes: {
        DateTime: "string"
      },
      introspection: {
        endpoint: DUMMY_ENDPOINT,
        headers: {}
      },
      destination: "./src/gqty/index.ts",
      subscriptions: false,
      javascriptOutput: false,
      enumsAsStrings: false,
      preImport: ""
    };
    defaultFilePath = path.resolve(process.cwd(), "gqty.config.cjs");
    defaultGQtyConfig = {
      filepath: defaultFilePath,
      config: defaultConfig
    };
    gqtyConfigPromise = new Promise(async (resolve5) => {
      try {
        if (process.env.NODE_ENV === "test") {
          setTimeout(() => {
            resolve5(defaultGQtyConfig);
          }, 10);
        } else {
          const cjsLoader = (filePath) => {
            const requireConfig = module$1.createRequire((typeof document === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('gqty.cjs', document.baseURI).href)));
            return requireConfig(filePath);
          };
          const config = await cosmiconfig.cosmiconfig("gqty", {
            searchPlaces: ["gqty.config.cjs", "gqty.config.js", "package.json"],
            loaders: {
              ".cjs": cjsLoader,
              ".js": cjsLoader
            }
          }).search();
          if (!config || config.isEmpty) {
            const filepath = (config == null ? void 0 : config.filepath) || defaultFilePath;
            const NODE_ENV = process.env["NODE_ENV"];
            if (NODE_ENV !== "test" && NODE_ENV !== "production" && __innerState.isCLI) {
              const { format } = (await Promise.resolve().then(() => (init_prettier(), prettier_exports))).formatPrettier({
                parser: "typescript"
              });
              const config2 = __spreadValues({}, defaultConfig);
              delete config2.preImport;
              delete config2.enumsAsStrings;
              await fs.promises.writeFile(defaultFilePath, await format(`
                      /**
                       * @type {import("@gqty/cli").GQtyConfig}
                       */
                      const config = ${JSON.stringify(config2)};
                      
                      module.exports = config;`));
            }
            return resolve5({
              filepath,
              config: defaultConfig
            });
          }
          resolve5({
            config: getValidConfig(config.config),
            filepath: config.filepath
          });
        }
      } catch (err) {
        console.error(err);
        resolve5(defaultGQtyConfig);
      }
    });
  }
});
async function generate(schema, {
  preImport,
  scalarTypes,
  react,
  endpoint,
  enumsAsStrings,
  subscriptions,
  javascriptOutput
} = {}, { ignoreArgs } = {}) {
  var _a, _b, _c, _d, _e, _f, _g;
  const gqtyConfig = (await gqtyConfigPromise).config;
  const isJavascriptOutput = (_a = javascriptOutput != null ? javascriptOutput : gqtyConfig.javascriptOutput) != null ? _a : defaultConfig.javascriptOutput;
  if (isJavascriptOutput) {
    if (gqtyConfig.enumsAsStrings) {
      console.warn(`"enumsAsStrings" is automatically set as "true" with "javascriptOutput" enabled.`);
    }
    enumsAsStrings = true;
  } else {
    enumsAsStrings != null ? enumsAsStrings : enumsAsStrings = (_b = gqtyConfig.enumsAsStrings) != null ? _b : false;
  }
  scalarTypes || (scalarTypes = gqtyConfig.scalarTypes || defaultConfig.scalarTypes);
  endpoint || (endpoint = (_d = (_c = gqtyConfig.introspection) == null ? void 0 : _c.endpoint) != null ? _d : defaultConfig.introspection.endpoint);
  if (endpoint === DUMMY_ENDPOINT) {
    endpoint = "/api/graphql";
  }
  react != null ? react : react = (_e = gqtyConfig.react) != null ? _e : defaultConfig.react;
  preImport != null ? preImport : preImport = (_f = gqtyConfig.preImport) != null ? _f : defaultConfig.preImport;
  subscriptions != null ? subscriptions : subscriptions = (_g = gqtyConfig.subscriptions) != null ? _g : defaultConfig.subscriptions;
  const { format } = formatPrettier({
    parser: "typescript"
  });
  const codegenResultPromise = core.codegen({
    schema: graphql.parse(utils.printSchemaWithDirectives(schema)),
    config: {},
    documents: [],
    filename: "gqty.generated.ts",
    pluginMap: {
      typescript: typescriptPlugin__namespace
    },
    plugins: [
      {
        typescript: {
          onlyOperationTypes: true,
          declarationKind: "interface",
          addUnderscoreToArgsType: true,
          scalars: scalarTypes,
          namingConvention: "keep",
          enumsAsTypes: enumsAsStrings
        }
      }
    ]
  });
  const config = schema.toConfig();
  const scalarsEnumsHash = {};
  const enumsNames = [];
  const inputTypeNames = new Set();
  const generatedSchema = {
    query: {},
    mutation: {},
    subscription: {}
  };
  const queryType = config.query;
  const mutationType = config.mutation;
  const subscriptionType = config.subscription;
  const descriptions = new Map();
  const fieldsDescriptions = new Map();
  const fieldsArgsDescriptions = new Map();
  function addDescription(typeName) {
    var _a2, _b2, _c2;
    if (Array.isArray(typeName)) {
      const data = typeName[2] ? (_b2 = (_a2 = fieldsArgsDescriptions.get(typeName[0])) == null ? void 0 : _a2[typeName[1]]) == null ? void 0 : _b2[typeName[2]] : (_c2 = fieldsDescriptions.get(typeName[0])) == null ? void 0 : _c2[typeName[1]];
      let comment = "";
      if (data == null ? void 0 : data.description) {
        comment += "\n" + data.description.trim().split("\n").map((line) => "* " + line).join("\n");
      }
      if (data == null ? void 0 : data.deprecated) {
        comment += "\n* @deprecated " + data.deprecated.trim().replace(/\n/g, ". ").trim();
      }
      if (data == null ? void 0 : data.defaultValue) {
        comment += "\n* @defaultValue `" + data.defaultValue.trim() + "`";
      }
      return comment ? `/** ${comment} 
      */
` : "";
    } else {
      const desc = descriptions.get(typeName);
      return desc ? `/**
        ${desc.trim().split("\n").map((line) => "* " + line).join("\n")}
      */
` : "";
    }
  }
  const parseEnumType = (type) => {
    scalarsEnumsHash[type.name] = true;
    enumsNames.push(type.name);
    const values = type.getValues();
    const enumValuesDescriptions = {};
    for (const value of values) {
      if (value.isDeprecated || value.description) {
        enumValuesDescriptions[value.name] = {
          description: value.description,
          deprecated: value.isDeprecated ? value.deprecationReason : void 0
        };
      }
    }
    fieldsDescriptions.set(type.name, enumValuesDescriptions);
  };
  const parseScalarType = (type) => {
    scalarsEnumsHash[type.name] = true;
  };
  const objectTypeInterfacesMap = new Map();
  const parseObjectType = (type, typeName = type.name) => {
    const fields = type.getFields();
    const interfaces = type.getInterfaces();
    if (interfaces.length) {
      objectTypeInterfacesMap.set(type.name, interfaces.map((v) => v.name));
    }
    const schemaType = {
      __typename: { __type: "String!" }
    };
    const objectFieldsDescriptions = {};
    const objectFieldsArgsDescriptions = {};
    Object.entries(fields).forEach(([fieldName, gqlType]) => {
      if (gqlType.description || gqlType.isDeprecated) {
        objectFieldsDescriptions[fieldName] = {
          description: gqlType.description,
          deprecated: gqlType.isDeprecated ? gqlType.deprecationReason : null
        };
      }
      schemaType[fieldName] = {
        __type: gqlType.type.toString()
      };
      if (gqlType.args.length) {
        if (ignoreArgs) {
          const isEveryArgOptional = gqlType.args.every(({ type: type2 }) => {
            return graphql.isNullableType(type2);
          });
          if (isEveryArgOptional) {
            const shouldIgnore = ignoreArgs(gqlType);
            if (shouldIgnore)
              return;
          }
        }
        objectFieldsArgsDescriptions[fieldName] || (objectFieldsArgsDescriptions[fieldName] = {});
        schemaType[fieldName].__args = gqlType.args.reduce((acum, arg) => {
          acum[arg.name] = arg.type.toString();
          if (arg.description || arg.deprecationReason || arg.defaultValue != null) {
            objectFieldsArgsDescriptions[fieldName][arg.name] = {
              defaultValue: arg.defaultValue != null ? JSON.stringify(arg.defaultValue) : null,
              deprecated: arg.deprecationReason,
              description: arg.description
            };
          }
          return acum;
        }, {});
      }
    });
    fieldsDescriptions.set(type.name, objectFieldsDescriptions);
    fieldsArgsDescriptions.set(type.name, objectFieldsArgsDescriptions);
    generatedSchema[typeName] = schemaType;
  };
  const unionsMap = new Map();
  const parseUnionType = (type) => {
    const unionTypes = type.getTypes();
    const list = [];
    unionsMap.set(type.name, list);
    for (const objectType of unionTypes) {
      list.push(objectType.name);
    }
  };
  const parseInputType = (type) => {
    inputTypeNames.add(type.name);
    const fields = type.getFields();
    const schemaType = {};
    const inputFieldDescriptions = {};
    Object.entries(fields).forEach(([key, value]) => {
      schemaType[key] = {
        __type: value.type.toString()
      };
      if (value.description || value.deprecationReason || value.defaultValue) {
        inputFieldDescriptions[key] = {
          description: value.description,
          deprecated: value.deprecationReason,
          defaultValue: value.defaultValue != null ? JSON.stringify(value.defaultValue) : null
        };
      }
    });
    generatedSchema[type.name] = schemaType;
  };
  const interfacesMap = new Map();
  const parseInterfaceType = (type) => {
    const schemaType = {
      __typename: { __type: "String!" }
    };
    const fields = type.getFields();
    const interfaceFieldDescriptions = {};
    const objectFieldsArgsDescriptions = {};
    const list = Object.entries(fields).map(([fieldName, gqlType]) => {
      const interfaceValue = {
        fieldName,
        __type: gqlType.type.toString()
      };
      schemaType[fieldName] = {
        __type: gqlType.type.toString()
      };
      let hasArgs = true;
      if (gqlType.args.length) {
        if (ignoreArgs) {
          const isEveryArgOptional = gqlType.args.every(({ type: type2 }) => {
            return graphql.isNullableType(type2);
          });
          if (isEveryArgOptional) {
            const shouldIgnore = ignoreArgs(gqlType);
            if (shouldIgnore) {
              hasArgs = false;
            }
          }
        }
      } else {
        hasArgs = false;
      }
      if (hasArgs) {
        objectFieldsArgsDescriptions[fieldName] || (objectFieldsArgsDescriptions[fieldName] = {});
        schemaType[fieldName].__args = interfaceValue.__args = gqlType.args.reduce((acum, arg) => {
          acum[arg.name] = arg.type.toString();
          if (arg.description || arg.deprecationReason || arg.defaultValue != null) {
            objectFieldsArgsDescriptions[fieldName][arg.name] = {
              defaultValue: arg.defaultValue != null ? JSON.stringify(arg.defaultValue) : null,
              deprecated: arg.deprecationReason,
              description: arg.description
            };
          }
          return acum;
        }, {});
      }
      if (gqlType.description || gqlType.isDeprecated) {
        interfaceFieldDescriptions[fieldName] = {
          description: gqlType.description,
          deprecated: gqlType.isDeprecated ? gqlType.deprecationReason : null
        };
      }
      return interfaceValue;
    });
    fieldsDescriptions.set(type.name, interfaceFieldDescriptions);
    fieldsArgsDescriptions.set(type.name, objectFieldsArgsDescriptions);
    interfacesMap.set(type.name, list);
    generatedSchema[type.name] = schemaType;
  };
  config.types.forEach((type) => {
    if (type.description) {
      descriptions.set(type.name, type.description);
    }
    if (type.name.startsWith("__") || type === queryType || type === mutationType || type === subscriptionType) {
      return;
    }
    if (graphql.isScalarType(type)) {
      parseScalarType(type);
    } else if (graphql.isObjectType(type)) {
      parseObjectType(type);
    } else if (graphql.isInterfaceType(type)) {
      parseInterfaceType(type);
    } else if (graphql.isUnionType(type)) {
      parseUnionType(type);
    } else if (graphql.isEnumType(type)) {
      parseEnumType(type);
    } else if (graphql.isInputObjectType(type)) {
      parseInputType(type);
    }
  });
  if (queryType) {
    parseObjectType(queryType, "query");
  }
  if (mutationType) {
    parseObjectType(mutationType, "mutation");
  }
  if (subscriptionType) {
    parseObjectType(subscriptionType, "subscription");
  }
  const unionsMapObj = Array.from(unionsMap.entries()).reduce((acum, [key, value]) => {
    acum[key] = value;
    return acum;
  }, {});
  if (unionsMap.size) {
    generatedSchema[gqty.SchemaUnionsKey] = unionsMapObj;
  }
  function parseArgType({
    pureType,
    isArray,
    nullableItems,
    isNullable
  }) {
    let typeToReturn = [
      scalarsEnumsHash[pureType] ? enumsNames.includes(pureType) ? pureType : `Scalars["${pureType}"]` : pureType
    ];
    if (isArray) {
      typeToReturn = [
        "Array<",
        ...nullableItems ? ["Maybe<", ...typeToReturn, ">"] : typeToReturn,
        ">"
      ];
    }
    if (isNullable) {
      typeToReturn = ["Maybe<", ...typeToReturn, ">"];
    }
    return typeToReturn.join("");
  }
  function parseFinalType({
    pureType,
    isArray,
    nullableItems,
    isNullable
  }) {
    let typeToReturn = [
      scalarsEnumsHash[pureType] ? `ScalarsEnums["${pureType}"]` : pureType
    ];
    if (isArray) {
      typeToReturn = [
        "Array<",
        ...nullableItems ? ["Maybe<", ...typeToReturn, ">"] : typeToReturn,
        ">"
      ];
    }
    if (isNullable) {
      typeToReturn = ["Maybe<", ...typeToReturn, ">"];
    }
    return typeToReturn.join("");
  }
  const objectTypeTSTypes = new Map();
  let typescriptTypes = Object.entries(generatedSchema).reduce((acum, [typeKey, typeValue]) => {
    const typeName = (() => {
      switch (typeKey) {
        case "query": {
          return "Query";
        }
        case "mutation": {
          return "Mutation";
        }
        case "subscription": {
          return "Subscription";
        }
        default: {
          return typeKey;
        }
      }
    })();
    if (inputTypeNames.has(typeName))
      return acum;
    const objectTypeMap = new Map();
    objectTypeTSTypes.set(typeName, objectTypeMap);
    const objectTypeInterfaces = objectTypeInterfacesMap.get(typeName);
    acum += `

      ${addDescription(typeName)}export interface ${typeName} ${objectTypeInterfaces ? "extends " + objectTypeInterfaces.map((v) => `Omit<${v}, "__typename">`).join(", ") : ""}{ 
        __typename?: "${typeName}"; ${Object.entries(typeValue).reduce((acum2, [fieldKey, fieldValue]) => {
      if (fieldKey === "__typename") {
        objectTypeMap.set(fieldKey, `?: "${typeName}"`);
        return acum2;
      }
      const fieldValueProps = gqty.parseSchemaType(fieldValue.__type);
      const typeToReturn = parseFinalType(fieldValueProps);
      let finalType;
      if (fieldValue.__args) {
        const argsEntries = Object.entries(fieldValue.__args);
        let onlyNullableArgs = true;
        const argTypes = argsEntries.reduce((acum3, [argKey, argValue], index) => {
          const argValueProps = gqty.parseSchemaType(argValue);
          const connector = argValueProps.isNullable ? "?:" : ":";
          if (!argValueProps.isNullable) {
            onlyNullableArgs = false;
          }
          const argTypeValue = parseArgType(argValueProps);
          acum3 += `${addDescription([
            typeName,
            fieldKey,
            argKey
          ])}${argKey}${connector} ${argTypeValue}`;
          if (index < argsEntries.length - 1) {
            acum3 += "; ";
          }
          return acum3;
        }, "");
        const argsConnector = onlyNullableArgs ? "?:" : ":";
        finalType = `: (args${argsConnector} {${argTypes}}) => ${typeToReturn}`;
      } else {
        const connector = fieldValueProps.isNullable ? "?:" : ":";
        finalType = `${connector} ${typeToReturn}`;
      }
      objectTypeMap.set(fieldKey, finalType);
      acum2 += "\n" + addDescription([typeName, fieldKey]) + fieldKey + finalType;
      return acum2;
    }, "")}
      }
      `;
    return acum;
  }, "");
  const objectTypesEntries = Array.from(objectTypeTSTypes.entries());
  typescriptTypes += `
  export interface SchemaObjectTypes {
    ${objectTypesEntries.reduce((acum, [typeName]) => {
    acum += `${typeName}:${typeName};`;
    return acum;
  }, "")}
  }
  export type SchemaObjectTypesNames = ${objectTypesEntries.map(([key]) => `"${key}"`).join(" | ")};
  `;
  if (unionsMap.size) {
    typescriptTypes += `
    ${Array.from(unionsMap.entries()).reduce((acum, [unionName, types]) => {
      const allUnionFields = new Set();
      types.forEach((typeName) => {
        const typeMap = objectTypeTSTypes.get(typeName);
        if (typeMap) {
          typeMap.forEach((_value, fieldName) => allUnionFields.add(fieldName));
        }
      });
      const allUnionFieldsArray = Array.from(allUnionFields).sort();
      acum += `${addDescription(unionName)}export type ${unionName} = ${types.reduce((acumTypes, typeName) => {
        const typeMap = objectTypeTSTypes.get(typeName);
        if (typeMap) {
          acumTypes.push(`{ ${allUnionFieldsArray.map((fieldName) => {
            const foundType = typeMap.get(fieldName);
            return `${addDescription([
              typeName,
              fieldName
            ])}${fieldName}${foundType || "?: undefined"}
`;
          }).join("")} }`);
        }
        return acumTypes;
      }, []).join(" | ") || "{}"};`;
      return acum;
    }, "")}
    `;
  }
  if (interfacesMap.size) {
    typescriptTypes += `
    ${Array.from(interfacesMap.entries()).reduce((acum, [interfaceName, fields]) => {
      acum += `${addDescription(interfaceName)}export interface ${interfaceName} {
        ${fields.reduce((fieldAcum, { __type, fieldName, __args }) => {
        const fieldValueProps = gqty.parseSchemaType(__type);
        const typeToReturn = parseFinalType(fieldValueProps);
        if (__args) {
          const argsEntries = Object.entries(__args);
          let onlyNullableArgs = true;
          const argTypes = argsEntries.reduce((acum2, [argKey, argValue], index) => {
            const argValueProps = gqty.parseSchemaType(argValue);
            const connector = argValueProps.isNullable ? "?:" : ":";
            if (!argValueProps.isNullable) {
              onlyNullableArgs = false;
            }
            const argTypeValue = parseFinalType(argValueProps);
            acum2 += `${argKey}${connector} ${argTypeValue}`;
            if (index < argsEntries.length - 1) {
              acum2 += "; ";
            }
            return acum2;
          }, "");
          const argsConnector = onlyNullableArgs ? "?:" : ":";
          acum += `
            ${addDescription([
            interfaceName,
            fieldName
          ])}${fieldName}: (args${argsConnector} {${argTypes}}) => ${typeToReturn}`;
        } else {
          const connector = fieldValueProps.isNullable ? "?:" : ":";
          fieldAcum += `
            ${addDescription([
            interfaceName,
            fieldName
          ])}${fieldName}${connector} ${typeToReturn}`;
        }
        return fieldAcum;
      }, "")}
      }`;
      return acum;
    }, "")}
    `;
  }
  typescriptTypes += `
    export interface GeneratedSchema {
      query: Query
      mutation: Mutation
      subscription: Subscription
    }
    `;
  typescriptTypes += `
    export type MakeNullable<T> = {
      [K in keyof T]: T[K] | undefined;
    };
  
    export interface ScalarsEnums extends MakeNullable<Scalars> {
      ${enumsNames.reduce((acum, enumName) => {
    acum += `${enumName}: ${enumName} | undefined;`;
    return acum;
  }, "")}
    }
    `;
  function typeDoc(type) {
    return `/**
 * @type {${type}}
 */
`;
  }
  const queryFetcher = `
    ${isJavascriptOutput ? typeDoc('import("gqty").QueryFetcher') + "const queryFetcher" : "const queryFetcher : QueryFetcher"} = async function (query, variables) {
        // Modify "${endpoint}" if needed
        const response = await fetch("${endpoint}", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            query,
            variables,
          }),
          mode: "cors",
        });
            
        const json = await response.json();
      
        return json;
      };
    `;
  const hasUnions = !!unionsMap.size;
  const javascriptSchemaCode = await format(`
/**
 * GQTY AUTO-GENERATED CODE: PLEASE DO NOT MODIFY MANUALLY
 */
${hasUnions ? 'import { SchemaUnionsKey } from "gqty";' : ""}

${typeDoc('import("gqty").ScalarsEnumsHash')}export const scalarsEnumsHash = ${JSON.stringify(scalarsEnumsHash)};

export const generatedSchema = {${Object.entries(generatedSchema).reduceRight((acum, [key, value]) => {
    return `${JSON.stringify(key)}:${JSON.stringify(value)}, ${acum}`;
  }, hasUnions ? `[SchemaUnionsKey]: ${JSON.stringify(unionsMapObj)}` : "")}};
  `);
  const schemaCode = await format(`
/**
 * GQTY AUTO-GENERATED CODE: PLEASE DO NOT MODIFY MANUALLY
 */
  ${preImport}

  ${hasUnions ? 'import { SchemaUnionsKey } from "gqty";' : ""}

  ${await codegenResultPromise}

  export${isJavascriptOutput ? " declare" : ""} const scalarsEnumsHash: import("gqty").ScalarsEnumsHash${isJavascriptOutput ? ";" : ` = ${JSON.stringify(scalarsEnumsHash)};`}
  export${isJavascriptOutput ? " declare" : ""} const generatedSchema ${isJavascriptOutput ? ":" : "="} {${Object.entries(generatedSchema).reduceRight((acum, [key, value]) => {
    return `${JSON.stringify(key)}:${JSON.stringify(value)}, ${acum}`;
  }, hasUnions ? `[SchemaUnionsKey]: ${JSON.stringify(unionsMapObj)}` : "")}}${isJavascriptOutput ? "" : " as const"};

  ${typescriptTypes}
    `);
  let reactClientCode = "";
  if (react) {
    if (isJavascriptOutput) {
      reactClientCode = `
      ${typeDoc('import("@gqty/react").ReactClient<import("./schema.generated").GeneratedSchema>')}const reactClient = createReactClient(client, {
        defaults: {
          // Set this flag as "true" if your usage involves React Suspense
          // Keep in mind that you can overwrite it in a per-hook basis
          suspense: false,
    
          // Set this flag based on your needs
          staleWhileRevalidate: false
        }
      });

      export const {
        graphql,
        useQuery,
        usePaginatedQuery,
        useTransactionQuery,
        useLazyQuery,
        useRefetch,
        useMutation,
        useMetaState,
        prepareReactRender,
        useHydrateCache,
        prepareQuery,
      } = reactClient;
      `.trim();
    } else {
      reactClientCode = `export const {
        graphql,
        useQuery,
        usePaginatedQuery,
        useTransactionQuery,
        useLazyQuery,
        useRefetch,
        useMutation,
        useMetaState,
        prepareReactRender,
        useHydrateCache,
        prepareQuery,
        ${subscriptions ? "useSubscription," : ""}    
      } = createReactClient<GeneratedSchema>(client, {
        defaults: {
          // Set this flag as "true" if your usage involves React Suspense
          // Keep in mind that you can overwrite it in a per-hook basis
          suspense: false,
    
          // Set this flag based on your needs
          staleWhileRevalidate: false
        }
      });`;
    }
  }
  const clientCode = await format(`
/**
 * GQTY: You can safely modify this file and Query Fetcher based on your needs
 */

  ${react ? `import { createReactClient } from "@gqty/react"` : ""}
  ${subscriptions ? `import { createSubscriptionsClient } from "@gqty/subscriptions"` : ""}
  import { createClient${isJavascriptOutput ? "" : ", QueryFetcher"} } from "gqty";
  import { generatedSchema, scalarsEnumsHash${isJavascriptOutput ? "" : ", GeneratedSchema, SchemaObjectTypes, SchemaObjectTypesNames"} } from "./schema.generated";

  ${queryFetcher}

  ${subscriptions ? `
  const subscriptionsClient = 
  typeof window !== "undefined" ?
  createSubscriptionsClient({
    wsEndpoint: () => {
      // Modify if needed
      const url = new URL("${endpoint}", window.location.href);
      url.protocol = url.protocol.replace('http', 'ws');
      return url.href;
    }
  }) : undefined;
  ` : ""}

  ${isJavascriptOutput ? `${typeDoc('import("gqty").GQtyClient<import("./schema.generated").GeneratedSchema>')}export const client = createClient({
        schema: generatedSchema,
        scalarsEnumsHash, 
        queryFetcher
        ${subscriptions ? ", subscriptionsClient" : ""}
      });` : `export const client = createClient<GeneratedSchema, SchemaObjectTypesNames, SchemaObjectTypes>({ 
    schema: generatedSchema, 
    scalarsEnumsHash, 
    queryFetcher
    ${subscriptions ? ", subscriptionsClient" : ""}
  });`}
  

  export const { query, mutation, mutate, subscription, resolved, refetch, track } = client;

  ${reactClientCode}

  export * from "./schema.generated";
  `);
  return {
    clientCode,
    schemaCode,
    javascriptSchemaCode,
    generatedSchema,
    scalarsEnumsHash,
    isJavascriptOutput
  };
}
var init_generate = __esm({
  "src/generate.ts"() {
    init_config();
    init_prettier();
  }
});

// src/introspection.ts
var introspection_exports = {};
__export(introspection_exports, {
  getRemoteSchema: () => getRemoteSchema
});
var getRemoteSchema;
var init_introspection = __esm({
  "src/introspection.ts"() {
    init_config();
    getRemoteSchema = async (endpoint, { headers } = {}) => {
      const executor = async ({ document, variables }) => {
        var _a;
        headers || (headers = ((_a = (await gqtyConfigPromise).config.introspection) == null ? void 0 : _a.headers) || defaultConfig.introspection.headers);
        const query = graphql.print(document);
        const fetchResult = await crossFetch.fetch(endpoint, {
          method: "POST",
          headers: __spreadValues({
            "Content-Type": "application/json"
          }, headers),
          body: JSON.stringify({ query, variables })
        });
        return fetchResult.json();
      };
      const schema = wrap.wrapSchema({
        schema: await wrap.introspectSchema(executor, {
          endpoint
        }),
        executor
      });
      return schema;
    };
  }
});

// src/writeGenerate.ts
var writeGenerate_exports = {};
__export(writeGenerate_exports, {
  writeGenerate: () => writeGenerate
});
async function writeClientCode({
  destinationPath,
  clientCode,
  onExistingFileConflict
}) {
  if (fs.existsSync(destinationPath)) {
    if (onExistingFileConflict) {
      const existingFile = await fs.promises.readFile(destinationPath, {
        encoding: "utf-8"
      });
      onExistingFileConflict(existingFile);
    }
    return;
  }
  await fs.promises.writeFile(destinationPath, clientCode, {
    encoding: "utf-8"
  });
}
function waitFunctions(...fns) {
  return Promise.all(fns.map((fn) => fn()));
}
async function writeSchemaCode({
  schemaCode,
  destinationPath,
  isJavascriptOutput,
  javascriptSchemaCode
}) {
  await waitFunctions(async () => {
    const schemaPath = path.resolve(path.dirname(destinationPath), isJavascriptOutput ? "./schema.generated.d.ts" : "./schema.generated.ts");
    if (fs.existsSync(schemaPath)) {
      const existingCode = await fs.promises.readFile(schemaPath, {
        encoding: "utf-8"
      });
      if (existingCode === schemaCode)
        return;
    }
    await fs.promises.writeFile(schemaPath, schemaCode, {
      encoding: "utf-8"
    });
  }, async () => {
    if (isJavascriptOutput) {
      const schemaPath = path.resolve(path.dirname(destinationPath), "./schema.generated.js");
      if (fs.existsSync(schemaPath)) {
        const existingCode = await fs.promises.readFile(schemaPath, {
          encoding: "utf-8"
        });
        if (existingCode === javascriptSchemaCode)
          return;
      }
      await fs.promises.writeFile(schemaPath, javascriptSchemaCode, {
        encoding: "utf-8"
      });
    }
  });
}
async function writeGenerate(schema, destinationPath, generateOptions = {}, onExistingFileConflict, transformsGenerate) {
  var _a, _b;
  const isJavascriptOutput = (_b = (_a = generateOptions.javascriptOutput) != null ? _a : (await gqtyConfigPromise).config.javascriptOutput) != null ? _b : defaultConfig.javascriptOutput;
  if (isJavascriptOutput) {
    if (!destinationPath.endsWith(".js")) {
      const err = Error('You have to specify the ".js" extension, instead, it received: "' + destinationPath + '"');
      Error.captureStackTrace(err, writeGenerate);
      throw err;
    }
  } else if (!destinationPath.endsWith(".ts")) {
    const err = Error('You have to specify the ".ts" extension, instead, it received: "' + destinationPath + '"');
    Error.captureStackTrace(err, writeGenerate);
    throw err;
  }
  destinationPath = path.resolve(destinationPath);
  const [{ clientCode, schemaCode, javascriptSchemaCode }] = await Promise.all([
    generate(schema, generateOptions, transformsGenerate),
    mkdirp__default['default'](path.dirname(destinationPath))
  ]);
  await Promise.all([
    writeClientCode({ clientCode, destinationPath, onExistingFileConflict }),
    writeSchemaCode({
      schemaCode,
      destinationPath,
      isJavascriptOutput,
      javascriptSchemaCode
    })
  ]);
  return destinationPath;
}
var init_writeGenerate = __esm({
  "src/writeGenerate.ts"() {
    init_config();
    init_generate();
  }
});

// src/index.ts
init_generate();

// src/inspectWriteGenerate.ts
init_config();
async function inspectWriteGenerate({
  endpoint,
  destination,
  generateOptions,
  cli,
  headers,
  transformSchemaOptions
} = {}) {
  if (destination) {
    defaultConfig.destination = destination;
  }
  if (endpoint) {
    defaultConfig.introspection.endpoint = endpoint;
  } else if (fs.existsSync(path.resolve("./schema.gql"))) {
    endpoint = "./schema.gql";
    defaultConfig.introspection.endpoint = endpoint;
  } else {
    const { config, filepath } = await gqtyConfigPromise;
    const configIntrospectionEndpoint = config.introspection && config.introspection.endpoint;
    if (configIntrospectionEndpoint && configIntrospectionEndpoint !== DUMMY_ENDPOINT) {
      endpoint = configIntrospectionEndpoint;
    } else {
      console.error(`
Please modify "${filepath.endsWith("package.json") ? "gqty" : "config"}.introspection.endpoint" in: "${filepath}".`);
      throw Error("ERROR: No introspection endpoint specified in configuration file.");
    }
  }
  if (!destination) {
    const configDestination = (await gqtyConfigPromise).config.destination;
    destination = configDestination || defaultConfig.destination;
  }
  destination = path.resolve(destination);
  const genOptions = Object.assign({}, generateOptions);
  let schema;
  defaultConfig.introspection.endpoint = endpoint;
  defaultConfig.introspection.headers = headers || {};
  if (endpoint.startsWith("http://") || endpoint.startsWith("https://")) {
    schema = await (await Promise.resolve().then(() => (init_introspection(), introspection_exports))).getRemoteSchema(endpoint, {
      headers
    });
  } else {
    defaultConfig.introspection.endpoint = DUMMY_ENDPOINT;
    if (fs.existsSync(endpoint)) {
      const file = await fs.promises.readFile(endpoint, {
        encoding: "utf-8"
      });
      if (endpoint.endsWith(".json")) {
        const parsedFile = JSON.parse(file);
        let dataField;
        if (typeof parsedFile === "object") {
          if ("data" in parsedFile && parsedFile.data) {
            dataField = parsedFile.data;
          } else if ("__schema" in parsedFile) {
            dataField = parsedFile;
          }
        }
        if (!(typeof dataField === "object"))
          throw Error('Invalid JSON introspection result, expected "__schema" or "data.__schema" field.');
        schema = graphql.buildClientSchema(dataField);
      } else {
        schema = graphql.buildSchema(file);
      }
    } else {
      throw Error(`File "${endpoint}" doesn't exists. If you meant to inspect a GraphQL API, make sure to put http:// or https:// in front of it.`);
    }
  }
  const generatedPath = await (await Promise.resolve().then(() => (init_writeGenerate(), writeGenerate_exports))).writeGenerate(schema, destination, genOptions, async (existingFile) => {
    var _a, _b;
    const subscriptions = (_a = genOptions.subscriptions) != null ? _a : (await gqtyConfigPromise).config.subscriptions;
    const react = (_b = genOptions.react) != null ? _b : (await gqtyConfigPromise).config.react;
    const advice = `
If you meant to change this, please remove "${destination}" and re-run code generation.`;
    if (subscriptions) {
      if (!existingFile.includes("createSubscriptionsClient")) {
        console.warn(`[Warning] You've changed the option "subscriptions" to 'true', which is different from your existing "${destination}".` + advice);
      }
    }
    if (react) {
      if (!existingFile.includes("createReactClient")) {
        console.warn(`[Warning] You've changed the option "react" to 'true', which is different from your existing "${destination}".` + advice);
      }
    }
  }, transformSchemaOptions);
  if (cli) {
    console.log("Code generated successfully at " + generatedPath);
  }
}

// src/index.ts
init_introspection();
init_writeGenerate();
init_config();
init_innerState();

// src/bin.ts
__innerState.isCLI = true;
commander.program.version(JSON.parse(fs.readFileSync(path.resolve(path.dirname(url.fileURLToPath((typeof document === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('gqty.cjs', document.baseURI).href)))), "../package.json"), {
  encoding: "utf-8"
})).version).description("CLI for gqty");
commander.program.command("generate [endpoint] [destination]").option("--react", "Create React client").description(`Inspect or read from a file a GraphQL Schema and generate the gqty client in the specified directory (./src/generated/graphql.ts by default).
EXAMPLE 1: "gqty generate ./schema.gql --react" 
EXAMPLE 2: "gqty generate http://localhost:3000/graphql src/gqty/index.ts"
EXAMPLE 3 (Configuration file): "gqty generate"`).action(async (endpoint, destination, opts) => {
  let react;
  if (opts.react != null) {
    react = defaultConfig.react = typeof opts.react === "boolean" ? opts.react : !!opts.react;
  }
  await inspectWriteGenerate({
    endpoint,
    destination,
    cli: true,
    generateOptions: {
      react
    }
  }).catch((err) => {
    if (err instanceof Error)
      delete err.stack;
    console.error(err);
    process.exit(1);
  });
  process.exit(0);
});
commander.program.parse(process.argv);
