'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const gqty = require('gqty');
const graphql = require('graphql');
const core = require('@graphql-codegen/core');
const typescriptPlugin = require('@graphql-codegen/typescript');
const utils = require('@graphql-tools/utils');
const config = require('./config.js');
const prettier = require('./prettier.js');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

const typescriptPlugin__namespace = /*#__PURE__*/_interopNamespace(typescriptPlugin);

async function generate(schema, {
  preImport,
  scalarTypes,
  react,
  endpoint,
  enumsAsStrings,
  subscriptions,
  javascriptOutput
} = {}, { ignoreArgs } = {}) {
  var _a, _b, _c, _d, _e, _f, _g;
  const gqtyConfig = (await config.gqtyConfigPromise).config;
  const isJavascriptOutput = (_a = javascriptOutput != null ? javascriptOutput : gqtyConfig.javascriptOutput) != null ? _a : config.defaultConfig.javascriptOutput;
  if (isJavascriptOutput) {
    if (gqtyConfig.enumsAsStrings) {
      console.warn(`"enumsAsStrings" is automatically set as "true" with "javascriptOutput" enabled.`);
    }
    enumsAsStrings = true;
  } else {
    enumsAsStrings != null ? enumsAsStrings : enumsAsStrings = (_b = gqtyConfig.enumsAsStrings) != null ? _b : false;
  }
  scalarTypes || (scalarTypes = gqtyConfig.scalarTypes || config.defaultConfig.scalarTypes);
  endpoint || (endpoint = (_d = (_c = gqtyConfig.introspection) == null ? void 0 : _c.endpoint) != null ? _d : config.defaultConfig.introspection.endpoint);
  if (endpoint === config.DUMMY_ENDPOINT) {
    endpoint = "/api/graphql";
  }
  react != null ? react : react = (_e = gqtyConfig.react) != null ? _e : config.defaultConfig.react;
  preImport != null ? preImport : preImport = (_f = gqtyConfig.preImport) != null ? _f : config.defaultConfig.preImport;
  subscriptions != null ? subscriptions : subscriptions = (_g = gqtyConfig.subscriptions) != null ? _g : config.defaultConfig.subscriptions;
  const { format } = prettier.formatPrettier({
    parser: "typescript"
  });
  const codegenResultPromise = core.codegen({
    schema: graphql.parse(utils.printSchemaWithDirectives(schema)),
    config: {},
    documents: [],
    filename: "gqty.generated.ts",
    pluginMap: {
      typescript: typescriptPlugin__namespace
    },
    plugins: [
      {
        typescript: {
          onlyOperationTypes: true,
          declarationKind: "interface",
          addUnderscoreToArgsType: true,
          scalars: scalarTypes,
          namingConvention: "keep",
          enumsAsTypes: enumsAsStrings
        }
      }
    ]
  });
  const config$1 = schema.toConfig();
  const scalarsEnumsHash = {};
  const enumsNames = [];
  const inputTypeNames = new Set();
  const generatedSchema = {
    query: {},
    mutation: {},
    subscription: {}
  };
  const queryType = config$1.query;
  const mutationType = config$1.mutation;
  const subscriptionType = config$1.subscription;
  const descriptions = new Map();
  const fieldsDescriptions = new Map();
  const fieldsArgsDescriptions = new Map();
  function addDescription(typeName) {
    var _a2, _b2, _c2;
    if (Array.isArray(typeName)) {
      const data = typeName[2] ? (_b2 = (_a2 = fieldsArgsDescriptions.get(typeName[0])) == null ? void 0 : _a2[typeName[1]]) == null ? void 0 : _b2[typeName[2]] : (_c2 = fieldsDescriptions.get(typeName[0])) == null ? void 0 : _c2[typeName[1]];
      let comment = "";
      if (data == null ? void 0 : data.description) {
        comment += "\n" + data.description.trim().split("\n").map((line) => "* " + line).join("\n");
      }
      if (data == null ? void 0 : data.deprecated) {
        comment += "\n* @deprecated " + data.deprecated.trim().replace(/\n/g, ". ").trim();
      }
      if (data == null ? void 0 : data.defaultValue) {
        comment += "\n* @defaultValue `" + data.defaultValue.trim() + "`";
      }
      return comment ? `/** ${comment} 
      */
` : "";
    } else {
      const desc = descriptions.get(typeName);
      return desc ? `/**
        ${desc.trim().split("\n").map((line) => "* " + line).join("\n")}
      */
` : "";
    }
  }
  const parseEnumType = (type) => {
    scalarsEnumsHash[type.name] = true;
    enumsNames.push(type.name);
    const values = type.getValues();
    const enumValuesDescriptions = {};
    for (const value of values) {
      if (value.isDeprecated || value.description) {
        enumValuesDescriptions[value.name] = {
          description: value.description,
          deprecated: value.isDeprecated ? value.deprecationReason : void 0
        };
      }
    }
    fieldsDescriptions.set(type.name, enumValuesDescriptions);
  };
  const parseScalarType = (type) => {
    scalarsEnumsHash[type.name] = true;
  };
  const objectTypeInterfacesMap = new Map();
  const parseObjectType = (type, typeName = type.name) => {
    const fields = type.getFields();
    const interfaces = type.getInterfaces();
    if (interfaces.length) {
      objectTypeInterfacesMap.set(type.name, interfaces.map((v) => v.name));
    }
    const schemaType = {
      __typename: { __type: "String!" }
    };
    const objectFieldsDescriptions = {};
    const objectFieldsArgsDescriptions = {};
    Object.entries(fields).forEach(([fieldName, gqlType]) => {
      if (gqlType.description || gqlType.isDeprecated) {
        objectFieldsDescriptions[fieldName] = {
          description: gqlType.description,
          deprecated: gqlType.isDeprecated ? gqlType.deprecationReason : null
        };
      }
      schemaType[fieldName] = {
        __type: gqlType.type.toString()
      };
      if (gqlType.args.length) {
        if (ignoreArgs) {
          const isEveryArgOptional = gqlType.args.every(({ type: type2 }) => {
            return graphql.isNullableType(type2);
          });
          if (isEveryArgOptional) {
            const shouldIgnore = ignoreArgs(gqlType);
            if (shouldIgnore)
              return;
          }
        }
        objectFieldsArgsDescriptions[fieldName] || (objectFieldsArgsDescriptions[fieldName] = {});
        schemaType[fieldName].__args = gqlType.args.reduce((acum, arg) => {
          acum[arg.name] = arg.type.toString();
          if (arg.description || arg.deprecationReason || arg.defaultValue != null) {
            objectFieldsArgsDescriptions[fieldName][arg.name] = {
              defaultValue: arg.defaultValue != null ? JSON.stringify(arg.defaultValue) : null,
              deprecated: arg.deprecationReason,
              description: arg.description
            };
          }
          return acum;
        }, {});
      }
    });
    fieldsDescriptions.set(type.name, objectFieldsDescriptions);
    fieldsArgsDescriptions.set(type.name, objectFieldsArgsDescriptions);
    generatedSchema[typeName] = schemaType;
  };
  const unionsMap = new Map();
  const parseUnionType = (type) => {
    const unionTypes = type.getTypes();
    const list = [];
    unionsMap.set(type.name, list);
    for (const objectType of unionTypes) {
      list.push(objectType.name);
    }
  };
  const parseInputType = (type) => {
    inputTypeNames.add(type.name);
    const fields = type.getFields();
    const schemaType = {};
    const inputFieldDescriptions = {};
    Object.entries(fields).forEach(([key, value]) => {
      schemaType[key] = {
        __type: value.type.toString()
      };
      if (value.description || value.deprecationReason || value.defaultValue) {
        inputFieldDescriptions[key] = {
          description: value.description,
          deprecated: value.deprecationReason,
          defaultValue: value.defaultValue != null ? JSON.stringify(value.defaultValue) : null
        };
      }
    });
    generatedSchema[type.name] = schemaType;
  };
  const interfacesMap = new Map();
  const parseInterfaceType = (type) => {
    const schemaType = {
      __typename: { __type: "String!" }
    };
    const fields = type.getFields();
    const interfaceFieldDescriptions = {};
    const objectFieldsArgsDescriptions = {};
    const list = Object.entries(fields).map(([fieldName, gqlType]) => {
      const interfaceValue = {
        fieldName,
        __type: gqlType.type.toString()
      };
      schemaType[fieldName] = {
        __type: gqlType.type.toString()
      };
      let hasArgs = true;
      if (gqlType.args.length) {
        if (ignoreArgs) {
          const isEveryArgOptional = gqlType.args.every(({ type: type2 }) => {
            return graphql.isNullableType(type2);
          });
          if (isEveryArgOptional) {
            const shouldIgnore = ignoreArgs(gqlType);
            if (shouldIgnore) {
              hasArgs = false;
            }
          }
        }
      } else {
        hasArgs = false;
      }
      if (hasArgs) {
        objectFieldsArgsDescriptions[fieldName] || (objectFieldsArgsDescriptions[fieldName] = {});
        schemaType[fieldName].__args = interfaceValue.__args = gqlType.args.reduce((acum, arg) => {
          acum[arg.name] = arg.type.toString();
          if (arg.description || arg.deprecationReason || arg.defaultValue != null) {
            objectFieldsArgsDescriptions[fieldName][arg.name] = {
              defaultValue: arg.defaultValue != null ? JSON.stringify(arg.defaultValue) : null,
              deprecated: arg.deprecationReason,
              description: arg.description
            };
          }
          return acum;
        }, {});
      }
      if (gqlType.description || gqlType.isDeprecated) {
        interfaceFieldDescriptions[fieldName] = {
          description: gqlType.description,
          deprecated: gqlType.isDeprecated ? gqlType.deprecationReason : null
        };
      }
      return interfaceValue;
    });
    fieldsDescriptions.set(type.name, interfaceFieldDescriptions);
    fieldsArgsDescriptions.set(type.name, objectFieldsArgsDescriptions);
    interfacesMap.set(type.name, list);
    generatedSchema[type.name] = schemaType;
  };
  config$1.types.forEach((type) => {
    if (type.description) {
      descriptions.set(type.name, type.description);
    }
    if (type.name.startsWith("__") || type === queryType || type === mutationType || type === subscriptionType) {
      return;
    }
    if (graphql.isScalarType(type)) {
      parseScalarType(type);
    } else if (graphql.isObjectType(type)) {
      parseObjectType(type);
    } else if (graphql.isInterfaceType(type)) {
      parseInterfaceType(type);
    } else if (graphql.isUnionType(type)) {
      parseUnionType(type);
    } else if (graphql.isEnumType(type)) {
      parseEnumType(type);
    } else if (graphql.isInputObjectType(type)) {
      parseInputType(type);
    }
  });
  if (queryType) {
    parseObjectType(queryType, "query");
  }
  if (mutationType) {
    parseObjectType(mutationType, "mutation");
  }
  if (subscriptionType) {
    parseObjectType(subscriptionType, "subscription");
  }
  const unionsMapObj = Array.from(unionsMap.entries()).reduce((acum, [key, value]) => {
    acum[key] = value;
    return acum;
  }, {});
  if (unionsMap.size) {
    generatedSchema[gqty.SchemaUnionsKey] = unionsMapObj;
  }
  function parseArgType({
    pureType,
    isArray,
    nullableItems,
    isNullable
  }) {
    let typeToReturn = [
      scalarsEnumsHash[pureType] ? enumsNames.includes(pureType) ? pureType : `Scalars["${pureType}"]` : pureType
    ];
    if (isArray) {
      typeToReturn = [
        "Array<",
        ...nullableItems ? ["Maybe<", ...typeToReturn, ">"] : typeToReturn,
        ">"
      ];
    }
    if (isNullable) {
      typeToReturn = ["Maybe<", ...typeToReturn, ">"];
    }
    return typeToReturn.join("");
  }
  function parseFinalType({
    pureType,
    isArray,
    nullableItems,
    isNullable
  }) {
    let typeToReturn = [
      scalarsEnumsHash[pureType] ? `ScalarsEnums["${pureType}"]` : pureType
    ];
    if (isArray) {
      typeToReturn = [
        "Array<",
        ...nullableItems ? ["Maybe<", ...typeToReturn, ">"] : typeToReturn,
        ">"
      ];
    }
    if (isNullable) {
      typeToReturn = ["Maybe<", ...typeToReturn, ">"];
    }
    return typeToReturn.join("");
  }
  const objectTypeTSTypes = new Map();
  let typescriptTypes = Object.entries(generatedSchema).reduce((acum, [typeKey, typeValue]) => {
    const typeName = (() => {
      switch (typeKey) {
        case "query": {
          return "Query";
        }
        case "mutation": {
          return "Mutation";
        }
        case "subscription": {
          return "Subscription";
        }
        default: {
          return typeKey;
        }
      }
    })();
    if (inputTypeNames.has(typeName))
      return acum;
    const objectTypeMap = new Map();
    objectTypeTSTypes.set(typeName, objectTypeMap);
    const objectTypeInterfaces = objectTypeInterfacesMap.get(typeName);
    acum += `

      ${addDescription(typeName)}export interface ${typeName} ${objectTypeInterfaces ? "extends " + objectTypeInterfaces.map((v) => `Omit<${v}, "__typename">`).join(", ") : ""}{ 
        __typename?: "${typeName}"; ${Object.entries(typeValue).reduce((acum2, [fieldKey, fieldValue]) => {
      if (fieldKey === "__typename") {
        objectTypeMap.set(fieldKey, `?: "${typeName}"`);
        return acum2;
      }
      const fieldValueProps = gqty.parseSchemaType(fieldValue.__type);
      const typeToReturn = parseFinalType(fieldValueProps);
      let finalType;
      if (fieldValue.__args) {
        const argsEntries = Object.entries(fieldValue.__args);
        let onlyNullableArgs = true;
        const argTypes = argsEntries.reduce((acum3, [argKey, argValue], index) => {
          const argValueProps = gqty.parseSchemaType(argValue);
          const connector = argValueProps.isNullable ? "?:" : ":";
          if (!argValueProps.isNullable) {
            onlyNullableArgs = false;
          }
          const argTypeValue = parseArgType(argValueProps);
          acum3 += `${addDescription([
            typeName,
            fieldKey,
            argKey
          ])}${argKey}${connector} ${argTypeValue}`;
          if (index < argsEntries.length - 1) {
            acum3 += "; ";
          }
          return acum3;
        }, "");
        const argsConnector = onlyNullableArgs ? "?:" : ":";
        finalType = `: (args${argsConnector} {${argTypes}}) => ${typeToReturn}`;
      } else {
        const connector = fieldValueProps.isNullable ? "?:" : ":";
        finalType = `${connector} ${typeToReturn}`;
      }
      objectTypeMap.set(fieldKey, finalType);
      acum2 += "\n" + addDescription([typeName, fieldKey]) + fieldKey + finalType;
      return acum2;
    }, "")}
      }
      `;
    return acum;
  }, "");
  const objectTypesEntries = Array.from(objectTypeTSTypes.entries());
  typescriptTypes += `
  export interface SchemaObjectTypes {
    ${objectTypesEntries.reduce((acum, [typeName]) => {
    acum += `${typeName}:${typeName};`;
    return acum;
  }, "")}
  }
  export type SchemaObjectTypesNames = ${objectTypesEntries.map(([key]) => `"${key}"`).join(" | ")};
  `;
  if (unionsMap.size) {
    typescriptTypes += `
    ${Array.from(unionsMap.entries()).reduce((acum, [unionName, types]) => {
      const allUnionFields = new Set();
      types.forEach((typeName) => {
        const typeMap = objectTypeTSTypes.get(typeName);
        if (typeMap) {
          typeMap.forEach((_value, fieldName) => allUnionFields.add(fieldName));
        }
      });
      const allUnionFieldsArray = Array.from(allUnionFields).sort();
      acum += `${addDescription(unionName)}export type ${unionName} = ${types.reduce((acumTypes, typeName) => {
        const typeMap = objectTypeTSTypes.get(typeName);
        if (typeMap) {
          acumTypes.push(`{ ${allUnionFieldsArray.map((fieldName) => {
            const foundType = typeMap.get(fieldName);
            return `${addDescription([
              typeName,
              fieldName
            ])}${fieldName}${foundType || "?: undefined"}
`;
          }).join("")} }`);
        }
        return acumTypes;
      }, []).join(" | ") || "{}"};`;
      return acum;
    }, "")}
    `;
  }
  if (interfacesMap.size) {
    typescriptTypes += `
    ${Array.from(interfacesMap.entries()).reduce((acum, [interfaceName, fields]) => {
      acum += `${addDescription(interfaceName)}export interface ${interfaceName} {
        ${fields.reduce((fieldAcum, { __type, fieldName, __args }) => {
        const fieldValueProps = gqty.parseSchemaType(__type);
        const typeToReturn = parseFinalType(fieldValueProps);
        if (__args) {
          const argsEntries = Object.entries(__args);
          let onlyNullableArgs = true;
          const argTypes = argsEntries.reduce((acum2, [argKey, argValue], index) => {
            const argValueProps = gqty.parseSchemaType(argValue);
            const connector = argValueProps.isNullable ? "?:" : ":";
            if (!argValueProps.isNullable) {
              onlyNullableArgs = false;
            }
            const argTypeValue = parseFinalType(argValueProps);
            acum2 += `${argKey}${connector} ${argTypeValue}`;
            if (index < argsEntries.length - 1) {
              acum2 += "; ";
            }
            return acum2;
          }, "");
          const argsConnector = onlyNullableArgs ? "?:" : ":";
          acum += `
            ${addDescription([
            interfaceName,
            fieldName
          ])}${fieldName}: (args${argsConnector} {${argTypes}}) => ${typeToReturn}`;
        } else {
          const connector = fieldValueProps.isNullable ? "?:" : ":";
          fieldAcum += `
            ${addDescription([
            interfaceName,
            fieldName
          ])}${fieldName}${connector} ${typeToReturn}`;
        }
        return fieldAcum;
      }, "")}
      }`;
      return acum;
    }, "")}
    `;
  }
  typescriptTypes += `
    export interface GeneratedSchema {
      query: Query
      mutation: Mutation
      subscription: Subscription
    }
    `;
  typescriptTypes += `
    export type MakeNullable<T> = {
      [K in keyof T]: T[K] | undefined;
    };
  
    export interface ScalarsEnums extends MakeNullable<Scalars> {
      ${enumsNames.reduce((acum, enumName) => {
    acum += `${enumName}: ${enumName} | undefined;`;
    return acum;
  }, "")}
    }
    `;
  function typeDoc(type) {
    return `/**
 * @type {${type}}
 */
`;
  }
  const queryFetcher = `
    ${isJavascriptOutput ? typeDoc('import("gqty").QueryFetcher') + "const queryFetcher" : "const queryFetcher : QueryFetcher"} = async function (query, variables) {
        // Modify "${endpoint}" if needed
        const response = await fetch("${endpoint}", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            query,
            variables,
          }),
          mode: "cors",
        });
            
        const json = await response.json();
      
        return json;
      };
    `;
  const hasUnions = !!unionsMap.size;
  const javascriptSchemaCode = await format(`
/**
 * GQTY AUTO-GENERATED CODE: PLEASE DO NOT MODIFY MANUALLY
 */
${hasUnions ? 'import { SchemaUnionsKey } from "gqty";' : ""}

${typeDoc('import("gqty").ScalarsEnumsHash')}export const scalarsEnumsHash = ${JSON.stringify(scalarsEnumsHash)};

export const generatedSchema = {${Object.entries(generatedSchema).reduceRight((acum, [key, value]) => {
    return `${JSON.stringify(key)}:${JSON.stringify(value)}, ${acum}`;
  }, hasUnions ? `[SchemaUnionsKey]: ${JSON.stringify(unionsMapObj)}` : "")}};
  `);
  const schemaCode = await format(`
/**
 * GQTY AUTO-GENERATED CODE: PLEASE DO NOT MODIFY MANUALLY
 */
  ${preImport}

  ${hasUnions ? 'import { SchemaUnionsKey } from "gqty";' : ""}

  ${await codegenResultPromise}

  export${isJavascriptOutput ? " declare" : ""} const scalarsEnumsHash: import("gqty").ScalarsEnumsHash${isJavascriptOutput ? ";" : ` = ${JSON.stringify(scalarsEnumsHash)};`}
  export${isJavascriptOutput ? " declare" : ""} const generatedSchema ${isJavascriptOutput ? ":" : "="} {${Object.entries(generatedSchema).reduceRight((acum, [key, value]) => {
    return `${JSON.stringify(key)}:${JSON.stringify(value)}, ${acum}`;
  }, hasUnions ? `[SchemaUnionsKey]: ${JSON.stringify(unionsMapObj)}` : "")}}${isJavascriptOutput ? "" : " as const"};

  ${typescriptTypes}
    `);
  let reactClientCode = "";
  if (react) {
    if (isJavascriptOutput) {
      reactClientCode = `
      ${typeDoc('import("@gqty/react").ReactClient<import("./schema.generated").GeneratedSchema>')}const reactClient = createReactClient(client, {
        defaults: {
          // Set this flag as "true" if your usage involves React Suspense
          // Keep in mind that you can overwrite it in a per-hook basis
          suspense: false,
    
          // Set this flag based on your needs
          staleWhileRevalidate: false
        }
      });

      export const {
        graphql,
        useQuery,
        usePaginatedQuery,
        useTransactionQuery,
        useLazyQuery,
        useRefetch,
        useMutation,
        useMetaState,
        prepareReactRender,
        useHydrateCache,
        prepareQuery,
      } = reactClient;
      `.trim();
    } else {
      reactClientCode = `export const {
        graphql,
        useQuery,
        usePaginatedQuery,
        useTransactionQuery,
        useLazyQuery,
        useRefetch,
        useMutation,
        useMetaState,
        prepareReactRender,
        useHydrateCache,
        prepareQuery,
        ${subscriptions ? "useSubscription," : ""}    
      } = createReactClient<GeneratedSchema>(client, {
        defaults: {
          // Set this flag as "true" if your usage involves React Suspense
          // Keep in mind that you can overwrite it in a per-hook basis
          suspense: false,
    
          // Set this flag based on your needs
          staleWhileRevalidate: false
        }
      });`;
    }
  }
  const clientCode = await format(`
/**
 * GQTY: You can safely modify this file and Query Fetcher based on your needs
 */

  ${react ? `import { createReactClient } from "@gqty/react"` : ""}
  ${subscriptions ? `import { createSubscriptionsClient } from "@gqty/subscriptions"` : ""}
  import { createClient${isJavascriptOutput ? "" : ", QueryFetcher"} } from "gqty";
  import { generatedSchema, scalarsEnumsHash${isJavascriptOutput ? "" : ", GeneratedSchema, SchemaObjectTypes, SchemaObjectTypesNames"} } from "./schema.generated";

  ${queryFetcher}

  ${subscriptions ? `
  const subscriptionsClient = 
  typeof window !== "undefined" ?
  createSubscriptionsClient({
    wsEndpoint: () => {
      // Modify if needed
      const url = new URL("${endpoint}", window.location.href);
      url.protocol = url.protocol.replace('http', 'ws');
      return url.href;
    }
  }) : undefined;
  ` : ""}

  ${isJavascriptOutput ? `${typeDoc('import("gqty").GQtyClient<import("./schema.generated").GeneratedSchema>')}export const client = createClient({
        schema: generatedSchema,
        scalarsEnumsHash, 
        queryFetcher
        ${subscriptions ? ", subscriptionsClient" : ""}
      });` : `export const client = createClient<GeneratedSchema, SchemaObjectTypesNames, SchemaObjectTypes>({ 
    schema: generatedSchema, 
    scalarsEnumsHash, 
    queryFetcher
    ${subscriptions ? ", subscriptionsClient" : ""}
  });`}
  

  export const { query, mutation, mutate, subscription, resolved, refetch, track } = client;

  ${reactClientCode}

  export * from "./schema.generated";
  `);
  return {
    clientCode,
    schemaCode,
    javascriptSchemaCode,
    generatedSchema,
    scalarsEnumsHash,
    isJavascriptOutput
  };
}

exports.generate = generate;
